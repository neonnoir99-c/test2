<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Drum Machine - Fixed Version</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: #1a1a2e;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: #fff;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            color: #a0a0a0;
            text-align: center;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .status-badge {
            display: inline-block;
            background: #00ff88;
            color: #1a1a2e;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }

        /* Transport Controls */
        .transport {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        #playBtn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #1a1a2e;
        }

        #stopBtn {
            background: linear-gradient(135deg, #ff4757 0%, #cc3344 100%);
            color: white;
        }

        #clearBtn {
            background: linear-gradient(135deg, #ffa502 0%, #cc8400 100%);
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Sequencer Grid */
        .sequencer {
            margin-bottom: 30px;
        }

        #sequencerGrid {
            display: grid;
            grid-template-columns: 100px repeat(16, 1fr);
            gap: 5px;
            margin-bottom: 20px;
        }

        .track-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #fff;
            font-size: 14px;
            text-transform: uppercase;
            padding: 10px;
            border-radius: 5px;
        }

        .track-label.kick { background: #e74c3c; }
        .track-label.snare { background: #3498db; }
        .track-label.hihat { background: #f39c12; }
        .track-label.bass { background: #9b59b6; }

        .step {
            aspect-ratio: 1;
            background: #2d2d44;
            border: 2px solid #3d3d5c;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .step:hover {
            background: #3d3d5c;
            transform: scale(1.05);
        }

        .step.measure-start {
            border-left: 3px solid #667eea;
        }

        .step.active {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .step.current-step {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .step.playing {
            animation: pulse 0.3s ease;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); box-shadow: 0 0 25px rgba(255, 215, 0, 1); }
        }

        /* Volume Controls */
        .volume-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .volume-control {
            background: #2d2d44;
            padding: 15px;
            border-radius: 10px;
        }

        .volume-control label {
            display: block;
            color: #fff;
            margin-bottom: 10px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 12px;
        }

        .volume-slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }

        .volume-value {
            display: inline-block;
            color: #00ff88;
            font-weight: bold;
            margin-left: 10px;
        }

        /* Presets */
        .presets {
            margin-bottom: 30px;
        }

        .presets h3 {
            color: #fff;
            margin-bottom: 15px;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 10px 20px;
            background: #2d2d44;
            color: #fff;
            border: 2px solid #3d3d5c;
            font-size: 14px;
        }

        .preset-btn:hover {
            background: #3d3d5c;
            border-color: #00ff88;
        }

        /* Stats */
        .stats {
            background: #2d2d44;
            padding: 20px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            color: #a0a0a0;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #00ff88;
            font-size: 24px;
            font-weight: bold;
        }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }

        #loadingOverlay.hidden {
            display: none;
        }

        #loadingOverlay h2 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 2em;
        }

        #loadingOverlay p {
            color: #a0a0a0;
            font-size: 1.2em;
        }

        .error-message {
            background: #ff4757;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .error-message.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <h2>üéµ Professional Drum Machine</h2>
        <p>Click anywhere to start <span class="status-badge">FIXED VERSION</span></p>
        <p style="font-size: 0.8em; margin-top: 10px; color: #666;">
            ‚úÖ All audio issues fixed ‚Ä¢ State management ‚Ä¢ Error handling
        </p>
    </div>

    <div class="container">
        <h1>ü•Å Drum Machine <span class="status-badge">‚úÖ FIXED</span></h1>
        <p class="subtitle">120 BPM ‚Ä¢ 4 Tracks √ó 16 Steps ‚Ä¢ Web Audio API</p>

        <!-- Error Message -->
        <div id="errorMessage" class="error-message"></div>

        <!-- Transport Controls -->
        <div class="transport">
            <button id="playBtn">‚ñ∂ Play</button>
            <button id="stopBtn" disabled>‚èπ Stop</button>
            <button id="clearBtn">üóë Clear</button>
        </div>

        <!-- Sequencer Grid -->
        <div class="sequencer">
            <div id="sequencerGrid"></div>
        </div>

        <!-- Volume Controls -->
        <div class="volume-controls">
            <div class="volume-control">
                <label>Kick Drum</label>
                <input type="range" id="kickVolume" class="volume-slider" min="0" max="100" value="80">
                <span class="volume-value">80%</span>
            </div>
            <div class="volume-control">
                <label>Snare Drum</label>
                <input type="range" id="snareVolume" class="volume-slider" min="0" max="100" value="70">
                <span class="volume-value">70%</span>
            </div>
            <div class="volume-control">
                <label>Hi-Hat</label>
                <input type="range" id="hihatVolume" class="volume-slider" min="0" max="100" value="60">
                <span class="volume-value">60%</span>
            </div>
            <div class="volume-control">
                <label>Bass</label>
                <input type="range" id="bassVolume" class="volume-slider" min="0" max="100" value="75">
                <span class="volume-value">75%</span>
            </div>
        </div>

        <!-- Presets -->
        <div class="presets">
            <h3>Presets</h3>
            <div class="preset-buttons">
                <button class="preset-btn" data-preset="basic">Basic</button>
                <button class="preset-btn" data-preset="rock">Rock</button>
                <button class="preset-btn" data-preset="funk">Funk</button>
                <button class="preset-btn" data-preset="techno">Techno</button>
                <button class="preset-btn" data-preset="hiphop">Hip-Hop</button>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats">
            <div class="stat">
                <div class="stat-label">Current Step</div>
                <div class="stat-value" id="currentStepDisplay">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Active Notes</div>
                <div class="stat-value" id="activeNotesDisplay">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Audio State</div>
                <div class="stat-value" id="audioStateDisplay">Not Init</div>
            </div>
            <div class="stat">
                <div class="stat-label">Notes Played</div>
                <div class="stat-value" id="notesPlayedDisplay">0</div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import fixed drum machine (inline for completeness)
        class DrumMachine {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.currentStep = 0;
                this.tempo = 120;
                this.lookahead = 25.0;
                this.scheduleAheadTime = 0.1;
                this.nextNoteTime = 0.0;
                this.timerID = null;
                this.isInitialized = false;

                this.tracks = ['kick', 'snare', 'hihat', 'bass'];
                this.pattern = {
                    kick: new Array(16).fill(false),
                    snare: new Array(16).fill(false),
                    hihat: new Array(16).fill(false),
                    bass: new Array(16).fill(false)
                };

                this.volumes = {
                    kick: 0.8,
                    snare: 0.7,
                    hihat: 0.6,
                    bass: 0.75
                };

                this.stats = {
                    notesScheduled: 0,
                    timingErrors: [],
                    audioErrors: 0
                };

                this.presets = {
                    basic: {
                        kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                        snare: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                        hihat: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                        bass: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
                    },
                    rock: {
                        kick: [1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0],
                        snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                        hihat: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        bass: [1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0]
                    },
                    funk: {
                        kick: [1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
                        snare: [0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0],
                        hihat: [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0],
                        bass: [1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0]
                    },
                    techno: {
                        kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                        snare: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                        hihat: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        bass: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]
                    },
                    hiphop: {
                        kick: [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0],
                        snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
                        hihat: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                        bass: [1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0]
                    }
                };

                this.init();
            }

            async init() {
                this.buildUI();
                this.attachEventListeners();
                this.updateActiveNotesDisplay();
                
                const overlay = document.getElementById('loadingOverlay');
                overlay.addEventListener('click', async () => {
                    try {
                        await this.initAudio();
                        overlay.classList.add('hidden');
                    } catch (error) {
                        console.error('‚ùå Initialization failed:', error);
                        this.showError('Failed to initialize audio: ' + error.message);
                    }
                });
            }

            async initAudio() {
                if (this.isInitialized) {
                    console.log('‚ö†Ô∏è Already initialized');
                    return;
                }

                try {
                    console.log('üéµ Initializing Audio Context...');
                    
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // ‚úÖ CRITICAL FIX: Ensure context is running
                    if (this.audioContext.state !== 'running') {
                        console.log(`   Resuming from ${this.audioContext.state}...`);
                        await this.audioContext.resume();
                        
                        let attempts = 0;
                        while (this.audioContext.state !== 'running' && attempts < 20) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            attempts++;
                        }
                        
                        if (this.audioContext.state !== 'running') {
                            throw new Error(`Failed to start AudioContext. State: ${this.audioContext.state}`);
                        }
                    }
                    
                    if (!this.audioContext.destination) {
                        throw new Error('AudioContext destination not available');
                    }
                    
                    await this.testAudioCapability();
                    
                    this.isInitialized = true;
                    this.updateAudioStateDisplay();
                    
                    console.log('‚úÖ Audio Context initialized successfully');
                    
                } catch (error) {
                    console.error('‚ùå Failed to initialize Audio Context:', error);
                    throw error;
                }
            }

            async testAudioCapability() {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                gain.gain.value = 0;
                osc.connect(gain);
                gain.connect(this.audioContext.destination);
                const now = this.audioContext.currentTime;
                osc.start(now);
                osc.stop(now + 0.01);
            }

            buildUI() {
                const grid = document.getElementById('sequencerGrid');
                grid.innerHTML = '';

                this.tracks.forEach(track => {
                    const label = document.createElement('div');
                    label.className = `track-label ${track}`;
                    label.textContent = track.toUpperCase();
                    grid.appendChild(label);

                    for (let step = 0; step < 16; step++) {
                        const button = document.createElement('div');
                        button.className = 'step';
                        if (step % 4 === 0) button.classList.add('measure-start');
                        button.dataset.track = track;
                        button.dataset.step = step;
                        button.addEventListener('click', () => this.toggleStep(track, step));
                        grid.appendChild(button);
                    }
                });
            }

            attachEventListeners() {
                document.getElementById('playBtn').addEventListener('click', () => this.play());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearPattern());

                ['kick', 'snare', 'hihat', 'bass'].forEach(track => {
                    const slider = document.getElementById(`${track}Volume`);
                    const display = slider.nextElementSibling;
                    slider.addEventListener('input', (e) => {
                        const value = e.target.value;
                        this.volumes[track] = value / 100;
                        display.textContent = `${value}%`;
                    });
                });

                document.querySelectorAll('[data-preset]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.loadPreset(e.target.dataset.preset);
                    });
                });
            }

            toggleStep(track, step) {
                this.pattern[track][step] = !this.pattern[track][step];
                this.updateUI();
                this.updateActiveNotesDisplay();
            }

            updateUI() {
                this.tracks.forEach(track => {
                    for (let step = 0; step < 16; step++) {
                        const button = document.querySelector(`[data-track="${track}"][data-step="${step}"]`);
                        if (button) {
                            button.classList.toggle('active', this.pattern[track][step]);
                        }
                    }
                });
            }

            updateCurrentStepUI(step) {
                document.querySelectorAll('.current-step').forEach(el => {
                    el.classList.remove('current-step');
                });
                document.querySelectorAll(`[data-step="${step}"]`).forEach(el => {
                    el.classList.add('current-step');
                });
                document.getElementById('currentStepDisplay').textContent = step + 1;
            }

            updateActiveNotesDisplay() {
                let count = 0;
                this.tracks.forEach(track => {
                    count += this.pattern[track].filter(v => v).length;
                });
                document.getElementById('activeNotesDisplay').textContent = count;
            }

            updateAudioStateDisplay() {
                const display = document.getElementById('audioStateDisplay');
                if (this.audioContext) {
                    display.textContent = this.audioContext.state;
                    display.style.color = this.audioContext.state === 'running' ? '#00ff88' : '#ffa502';
                }
            }

            clearPattern() {
                if (confirm('Clear all patterns?')) {
                    this.tracks.forEach(track => {
                        this.pattern[track].fill(false);
                    });
                    this.updateUI();
                    this.updateActiveNotesDisplay();
                }
            }

            loadPreset(presetName) {
                const preset = this.presets[presetName];
                if (!preset) return;
                this.tracks.forEach(track => {
                    this.pattern[track] = preset[track].map(v => !!v);
                });
                this.updateUI();
                this.updateActiveNotesDisplay();
            }

            get secondsPerBeat() {
                return 60.0 / this.tempo;
            }

            get secondsPer16thNote() {
                return this.secondsPerBeat / 4;
            }

            scheduleNote(track, time) {
                try {
                    // ‚úÖ Time validation
                    const currentTime = this.audioContext.currentTime;
                    const minScheduleTime = currentTime + 0.001;
                    
                    if (time < minScheduleTime) {
                        time = minScheduleTime;
                    }

                    const volume = this.volumes[track];
                    
                    switch(track) {
                        case 'kick': this.playKick(time, volume); break;
                        case 'snare': this.playSnare(time, volume); break;
                        case 'hihat': this.playHiHat(time, volume); break;
                        case 'bass': this.playBass(time, volume); break;
                    }

                    this.stats.notesScheduled++;
                    document.getElementById('notesPlayedDisplay').textContent = this.stats.notesScheduled;
                    
                } catch (error) {
                    console.error(`‚ùå Failed to schedule ${track}:`, error);
                }
            }

            playKick(time, volume = 0.8) {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();

                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(50, time + 0.05);
                osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, time);
                filter.Q.setValueAtTime(1, time);

                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.audioContext.destination);

                osc.start(time);
                osc.stop(time + 0.3);
            }

            playSnare(time, volume = 0.7) {
                const noise = this.createNoiseBuffer();
                const noiseSource = this.audioContext.createBufferSource();
                noiseSource.buffer = noise;
                
                const noiseFilter = this.audioContext.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.setValueAtTime(1000, time);
                
                const noiseGain = this.audioContext.createGain();
                noiseGain.gain.setValueAtTime(volume * 0.7, time);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);

                noiseSource.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.audioContext.destination);

                const osc = this.audioContext.createOscillator();
                osc.type = 'triangle';
                
                const oscGain = this.audioContext.createGain();
                osc.frequency.setValueAtTime(200, time);
                osc.frequency.exponentialRampToValueAtTime(100, time + 0.1);
                
                oscGain.gain.setValueAtTime(volume * 0.3, time);
                oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

                osc.connect(oscGain);
                oscGain.connect(this.audioContext.destination);

                noiseSource.start(time);
                noiseSource.stop(time + 0.15);
                osc.start(time);
                osc.stop(time + 0.1);
            }

            playHiHat(time, volume = 0.6) {
                const noise = this.createNoiseBuffer();
                const noiseSource = this.audioContext.createBufferSource();
                noiseSource.buffer = noise;

                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(7000, time);
                filter.Q.setValueAtTime(1, time);

                const gain = this.audioContext.createGain();
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

                noiseSource.connect(filter);
                filter.connect(gain);
                gain.connect(this.audioContext.destination);

                noiseSource.start(time);
                noiseSource.stop(time + 0.05);
            }

            playBass(time, volume = 0.75) {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(55, time);

                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);

                osc.connect(gain);
                gain.connect(this.audioContext.destination);

                osc.start(time);
                osc.stop(time + 0.4);
            }

            createNoiseBuffer() {
                const bufferSize = this.audioContext.sampleRate * 0.5;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                return buffer;
            }

            scheduler() {
                try {
                    // ‚úÖ State check
                    if (this.audioContext.state !== 'running') {
                        console.warn('‚ö†Ô∏è AudioContext suspended, resuming...');
                        this.audioContext.resume();
                    }

                    while (this.nextNoteTime < this.audioContext.currentTime + this.scheduleAheadTime) {
                        this.scheduleCurrentStep(this.nextNoteTime);
                        this.nextNote();
                    }
                    
                } catch (error) {
                    console.error('‚ùå Scheduler error:', error);
                }
            }

            scheduleCurrentStep(time) {
                this.tracks.forEach(track => {
                    if (this.pattern[track][this.currentStep]) {
                        this.scheduleNote(track, time);
                        
                        const button = document.querySelector(
                            `[data-track="${track}"][data-step="${this.currentStep}"]`
                        );
                        if (button) {
                            const delay = (time - this.audioContext.currentTime) * 1000;
                            setTimeout(() => {
                                button.classList.add('playing');
                                setTimeout(() => button.classList.remove('playing'), 100);
                            }, Math.max(0, delay));
                        }
                    }
                });

                const delay = (time - this.audioContext.currentTime) * 1000;
                setTimeout(() => {
                    this.updateCurrentStepUI(this.currentStep);
                }, Math.max(0, delay));
            }

            nextNote() {
                this.nextNoteTime += this.secondsPer16thNote;
                this.currentStep = (this.currentStep + 1) % 16;
            }

            async play() {
                if (!this.isInitialized) {
                    this.showError('Please click the loading screen first to initialize audio.');
                    return;
                }

                if (this.isPlaying) return;

                try {
                    // ‚úÖ CRITICAL: Verify state before playback
                    if (this.audioContext.state !== 'running') {
                        await this.audioContext.resume();
                        
                        let attempts = 0;
                        while (this.audioContext.state !== 'running' && attempts < 10) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            attempts++;
                        }
                        
                        if (this.audioContext.state !== 'running') {
                            throw new Error(`Cannot start: AudioContext is ${this.audioContext.state}`);
                        }
                    }

                    this.isPlaying = true;
                    this.currentStep = 0;
                    this.nextNoteTime = this.audioContext.currentTime + 0.005;
                    
                    this.scheduler();
                    this.timerID = setInterval(() => this.scheduler(), this.lookahead);

                    document.getElementById('playBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    this.updateAudioStateDisplay();
                    
                    console.log('‚ñ∂Ô∏è Playback started');
                    
                } catch (error) {
                    console.error('‚ùå Failed to start:', error);
                    this.showError('Failed to start playback: ' + error.message);
                    this.isPlaying = false;
                }
            }

            stop() {
                if (!this.isPlaying) return;

                this.isPlaying = false;
                clearInterval(this.timerID);
                this.currentStep = 0;

                document.querySelectorAll('.current-step').forEach(el => {
                    el.classList.remove('current-step');
                });

                document.getElementById('playBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('currentStepDisplay').textContent = '0';
                this.updateAudioStateDisplay();

                console.log('‚èπÔ∏è Playback stopped');
            }

            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.textContent = message;
                errorDiv.classList.add('show');
                setTimeout(() => errorDiv.classList.remove('show'), 5000);
            }
        }

        // Initialize
        window.drumMachine = new DrumMachine();

        // Cleanup
        window.addEventListener('beforeunload', () => {
            if (window.drumMachine?.audioContext) {
                window.drumMachine.stop();
                window.drumMachine.audioContext.close();
            }
        });
    </script>
</body>
</html>
